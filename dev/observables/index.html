<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Observables · Interact</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interact</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Observables</a><ul class="internal"><li><a class="toctext" href="#API-1">API</a></li></ul></li><li><a class="toctext" href="../widgets/">Widgets</a></li><li><a class="toctext" href="../custom_widgets/">Custom widgets</a></li><li><a class="toctext" href="../modifiers/">Modifiers</a></li><li><a class="toctext" href="../layout/">Layout</a></li><li><a class="toctext" href="../deploying/">Deploying the web app</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Observables</a></li></ul><a class="edit-page" href="https://github.com/JuliaGizmos/Interact.jl/blob/master/docs/src/observables.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Observables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Observables-1" href="#Observables-1">Observables</a></h1><p>Observables are like <code>Ref</code>s but you can listen to changes.</p><pre><code class="language-julia-repl">julia&gt; using Interact

julia&gt; observable = Observable(0)
Observable{Int64} with 0 listeners. Value:
0

julia&gt; h = on(observable) do val
           println(&quot;Got an update: &quot;, val)
       end
#1 (generic function with 1 method)

julia&gt; observable[] = 42
Got an update: 42
42</code></pre><p>To get the value of an observable index it with no arguments</p><pre><code class="language-julia-repl">julia&gt; observable[]
42</code></pre><p>To remove a handler use <code>off</code> with the return value of <code>on</code>:</p><pre><code class="language-julia-repl">julia&gt; off(observable, h)</code></pre><h3><a class="nav-anchor" id="How-is-it-different-from-Reactive.jl?-1" href="#How-is-it-different-from-Reactive.jl?-1">How is it different from Reactive.jl?</a></h3><p>The main difference is <code>Signal</code>s are manipulated mostly by converting one signal to another. For example, with signals, you can construct a changing UI by creating a <code>Signal</code> of UI objects and rendering them as the signal changes. On the other hand, you can use an Observable both as an input and an output. You can arbitrarily attach outputs to inputs allowing structuring code in a <a href="http://doc.qt.io/qt-4.8/signalsandslots.html">signals-and-slots</a> kind of pattern.</p><p>Another difference is Observables are synchronous, Signals are asynchronous. Observables may be better suited for an imperative style of programming.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><h3><a class="nav-anchor" id="Type-1" href="#Type-1">Type</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.Observable" href="#Observables.Observable"><code>Observables.Observable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Like a <code>Ref</code> but updates can be watched by adding a handler using <code>on</code>.</p></div></div></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.on-Tuple{Any,Observable}" href="#Observables.on-Tuple{Any,Observable}"><code>Observables.on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">on(f, o::AbstractObservable)</code></pre><p>Adds function <code>f</code> as listener to <code>o</code>. Whenever <code>o</code>&#39;s value is set via <code>o[] = val</code> <code>f</code> is called with <code>val</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.off-Tuple{Observable,Any}" href="#Observables.off-Tuple{Observable,Any}"><code>Observables.off</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">off(o::AbstractObservable, f)</code></pre><p>Removes <code>f</code> from listeners of <code>o</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{Observable,Any}" href="#Base.setindex!-Tuple{Observable,Any}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">o[] = val</code></pre><p>Updates the value of an <code>Observable</code> to <code>val</code> and call its listeners.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Observable}" href="#Base.getindex-Tuple{Observable}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">o[]</code></pre><p>Returns the current value of <code>o</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.onany-Tuple{Any,Vararg{Any,N} where N}" href="#Observables.onany-Tuple{Any,Vararg{Any,N} where N}"><code>Observables.onany</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">onany(f, args...)</code></pre><p>Calls <code>f</code> on updates to any oservable refs in <code>args</code>. <code>args</code> may contain any number of <code>Observable</code> ojects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other ojects in <code>args</code> are passed as-is.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map!-Tuple{Any,Observable,Vararg{Any,N} where N}" href="#Base.map!-Tuple{Any,Observable,Vararg{Any,N} where N}"><code>Base.map!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map!(f, o::Observable, args...)</code></pre><p>Updates <code>o</code> with the result of calling <code>f</code> with values extracted from args. <code>args</code> may contain any number of <code>Observable</code> ojects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other ojects in <code>args</code> are passed as-is.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.connect!-Tuple{Observable,Observable}" href="#Observables.connect!-Tuple{Observable,Observable}"><code>Observables.connect!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">connect!(o1::Observable, o2::Observable)</code></pre><p>Forward all updates to <code>o1</code> to <code>o2</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,Observable,Vararg{Any,N} where N}" href="#Base.map-Tuple{Any,Observable,Vararg{Any,N} where N}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, o::Observable, args...)</code></pre><p>Creates a new oservable ref which contains the result of <code>f</code> applied to values extracted from args. The second argument <code>o</code> must be an oservable ref for dispatch reasons. <code>args</code> may contain any number of <code>Observable</code> ojects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other ojects in <code>args</code> are passed as-is.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.throttle-Tuple{Any,Observable}" href="#Observables.throttle-Tuple{Any,Observable}"><code>Observables.throttle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>throttle(dt, input::AbstractObservable)</code></p><p>Throttle a signal to update at most once every <code>dt</code> seconds. The throttled signal holds the last update of the <code>input</code> signal during each <code>dt</code> second time window.</p></div></div></section><h3><a class="nav-anchor" id="Macros-1" href="#Macros-1">Macros</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.@map" href="#Observables.@map"><code>Observables.@map</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@map(expr)</code></p><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to compute expression <code>expr</code> using their value. The expression will be computed when <code>@map</code> is called and  every time the <code>AbstractObservables</code> are updated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; c = Observables.@map &amp;a + &amp;b;

julia&gt; c[]
5

julia&gt; a[] = 100
100

julia&gt; c[]
103</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.@map!" href="#Observables.@map!"><code>Observables.@map!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@map!(d, expr)</code></p><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to compute expression <code>expr</code> using their value: the expression will be computed every time the <code>AbstractObservables</code> are updated and <code>d</code> will be set to match that value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; c = Observable(10);

julia&gt; Observables.@map! c &amp;a + &amp;b;

julia&gt; c[]
10

julia&gt; a[] = 100
100

julia&gt; c[]
103</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.@on" href="#Observables.@on"><code>Observables.@on</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@on(expr)</code></p><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to execute expression <code>expr</code> using their value. The expression will be computed every time the <code>AbstractObservables</code> are updated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; Observables.@on println(&quot;The sum of a+b is $(&amp;a + &amp;b)&quot;);

julia&gt; a[] = 100;
The sum of a+b is 103</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../widgets/"><span class="direction">Next</span><span class="title">Widgets</span></a></footer></article></body></html>
